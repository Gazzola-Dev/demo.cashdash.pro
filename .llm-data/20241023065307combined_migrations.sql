-- From 20241023065307_add_user_roles.sql
CREATE TYPE public.app_role AS ENUM ('admin');
CREATE TYPE public.app_permission AS ENUM ('products.manage', 'orders.manage', 'users.manage', 'site.settings');

CREATE TABLE public.user_roles (
  id        UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id   UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role      public.app_role NOT NULL,
  UNIQUE (user_id, role)
);

CREATE TABLE public.role_permissions (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role         public.app_role NOT NULL,
  permission   public.app_permission NOT NULL,
  UNIQUE (role, permission)
);

INSERT INTO public.role_permissions (role, permission)
VALUES
  ('admin', 'products.manage'),
  ('admin', 'orders.manage'),
  ('admin', 'users.manage'),
  ('admin', 'site.settings');

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
  DECLARE
    claims JSONB;
    user_role public.app_role;
  BEGIN
    SELECT role INTO user_role FROM public.user_roles WHERE user_id = (event->>'user_id')::UUID;

    claims := event->'claims';

    IF user_role IS NOT NULL THEN
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    ELSE
      claims := jsonb_set(claims, '{user_role}', 'null');
    END IF;

    event := jsonb_set(event, '{claims}', claims);

    RETURN event;
  END;
$$;

GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

GRANT ALL ON TABLE public.role_permissions TO supabase_auth_admin;
REVOKE ALL ON TABLE public.role_permissions FROM authenticated, anon, public;

CREATE POLICY "Allow auth admin to read user roles"
ON public.user_roles
AS PERMISSIVE
FOR SELECT
TO supabase_auth_admin
USING (true);

CREATE OR REPLACE FUNCTION public.authorize(requested_permission public.app_permission)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  DECLARE
    bind_permissions INT;
    user_role public.app_role;
  BEGIN
    SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;

    SELECT COUNT(*) INTO bind_permissions
    FROM public.role_permissions
    WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;

    RETURN bind_permissions > 0;
  END;
$$;

-- Create a policy to allow users to select their own roles
create policy "Allow users to view their own roles" 
on public.user_roles
for select 
to authenticated
using (user_id = auth.uid());

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- NOTE: This policy is not ideal, since it allows all users to see all roles, but I (Aaron) wasn't able to get the RLS to work otherwise. 
GRANT SELECT ON public.user_roles TO authenticated;

